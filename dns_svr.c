// A simple server in the internet domain using TCP
// The port number is passed as an argument
// To compile: gcc server.c -o server
// Reference: Beej's networking guide

#define _POSIX_C_SOURCE 200112L
#define TWO_BYTES_HEADER 2
#define LOCAL_SVR_PORT "8053"
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "utils.h"
#include <assert.h>

unsigned char *client_for_upstream( unsigned char *client_msg, int msg_len, char *port, char *ipv4, int *len);
unsigned char *combine_header_msg(unsigned char *len_bytes, unsigned char* msg,int msg_len);
void print_bytes(unsigned char *bytes, int len);
void handle_req_res(unsigned char *full_msg);
unsigned char *get_res_msg(unsigned char* original_res,int msg_len);

int main(int argc, char** argv) {
	int sockfd_svr, newsockfd_svr, num_bytes, enable_svr, msg_len, upstream_res_len;
	unsigned char msg_len_bytes[TWO_BYTES_HEADER], *query_msg, *original_msg, *upstream_res, *upstream_res_msg ;
	struct addrinfo hints_svr, *res_svr;
	struct sockaddr_storage client_addr_svr;
	socklen_t client_addr_size_svr;

	if (argc < 3) {
		fprintf(stderr, "ERROR, both ipv4 address & port required\n");
		exit(EXIT_FAILURE);
	}

	/* Create address we're going to listen on (with given port number) */
	memset(&hints_svr, 0, sizeof hints_svr);
	hints_svr.ai_family = AF_INET;       // IPv4
	hints_svr.ai_socktype = SOCK_STREAM; // TCP
	hints_svr.ai_flags = AI_PASSIVE;     // for bind, listen, accept
	/* node (NULL means any interface), service (port), hints_svr, res_svr */
	getaddrinfo(NULL, LOCAL_SVR_PORT, &hints_svr, &res_svr);

	printf("Local Server Port: %s\n",LOCAL_SVR_PORT);
	printf("Upstream IPv4 : %s\n",argv[1]);
	printf("Upstream Port : %s\n",argv[2]);

	/* Create socket */
	sockfd_svr = socket(res_svr->ai_family, res_svr->ai_socktype, res_svr->ai_protocol);
	if (sockfd_svr < 0) {
		perror("socket");
		exit(EXIT_FAILURE);
	}

	/* Reuse port if possible */
	enable_svr = 1;
	if (setsockopt(sockfd_svr, SOL_SOCKET, SO_REUSEADDR, &enable_svr, sizeof(int)) < 0) {
		perror("setsockopt");
		exit(EXIT_FAILURE);
	}

	/* Bind address to the socket */
	if (bind(sockfd_svr, res_svr->ai_addr, res_svr->ai_addrlen) < 0) {
		perror("bind");
		exit(EXIT_FAILURE);
	}

	/* Listen on socket - means we're ready to accept connections,
	 * incoming connection requests will be queued, man 3 listen */
	if (listen(sockfd_svr, 5) < 0) {
		perror("listen");
		exit(EXIT_FAILURE);
	}

	/* Server not shutting down by itself - keeps running until manually terminanted,
	 * separate TCP Connection for each query/res with client(dig) */
	while(1){
		/* Accept a connection - blocks until a connection is ready to be accepted
		* Get back a new file descriptor to communicate on */
		client_addr_size_svr = sizeof client_addr_svr;
		newsockfd_svr = accept(sockfd_svr, (struct sockaddr*)&client_addr_svr, &client_addr_size_svr);
		if (newsockfd_svr < 0) {
			perror("accept");
			exit(EXIT_FAILURE);
		}

		/* Read length of query message from client - dig*/
		/* num_bytes is number of bytes read  */ 
		memset(msg_len_bytes, 'b', TWO_BYTES_HEADER);
		num_bytes = read(newsockfd_svr, msg_len_bytes, TWO_BYTES_HEADER);
		if (num_bytes < 0) {
			perror("write");
			exit(EXIT_FAILURE);
		}

		/* Two byte header : length of message not including the two byte itself*/
		msg_len = msg_len_bytes[0] + msg_len_bytes[1];
		printf("Message length bytes : %02x %02x\n",msg_len_bytes[0] ,msg_len_bytes[1]);

		printf("Msg Length : %d\n",msg_len);
		/* Read the rest of query message based on msg length */
		query_msg = (unsigned char*)malloc(sizeof(*query_msg)*(msg_len));
		num_bytes = read(newsockfd_svr, query_msg,msg_len);

		handle_req_res(query_msg);

		/* Original packet generated by dig */
		original_msg = combine_header_msg(msg_len_bytes,query_msg,msg_len);
		
		/* Response from upstream */
		upstream_res = client_for_upstream(original_msg,msg_len,argv[2], argv[1],&upstream_res_len);

		printf("Getting only upstream res is okay\n");
		/* Get response message from upstream without Two bytes header */
		upstream_res_msg = get_res_msg(upstream_res,(upstream_res_len-2));
		printf("Getting only upstream res msg is okay\n");

		handle_req_res(upstream_res_msg);
		printf("handling response is okay\n");


		/* Send answer back to client - dig */
		num_bytes = send(newsockfd_svr,upstream_res,upstream_res_len,0);
		if (num_bytes < 0) {
			perror("send");
			exit(EXIT_FAILURE);
		}

		printf("Here is len: %d\n", num_bytes);

		free(query_msg);
		// free(original_msg);
		// free(upstream_res);
		// free(upstream_res_msg);
		printf("----------------------------------------------------\n");
	}

    printf("dig ok\n");
	freeaddrinfo(res_svr);
	close(sockfd_svr);
	close(newsockfd_svr);
    printf("dig ok2\n");
	return 0;
}

unsigned char *client_for_upstream( unsigned char* client_msg, int msg_len, char *port, char *ipv4, int *total_msg_len){
	printf("Local Mock Server as client START here\n ");
	unsigned char res_len_bytes[2], *res_msg, *original_res;
	int upstream_sockfd, num_bytes, res_msg_len;
	struct addrinfo hints, *servinfo, *rp;

	printf("variables allocation done\n ");

	// Create address
	memset(&hints, 0, sizeof hints);
	printf("memset hints ");
	hints.ai_family = AF_INET;
	hints.ai_socktype = SOCK_STREAM;

	// Get addrinfo of server. From man page:
	// The getaddrinfo() function combines the functionality provided by the
	// gethostbyname(3) and getservbyname(3) functions into a single interface
	if ((getaddrinfo(ipv4, port, &hints, &servinfo)) < 0) {
		perror("getaddrinfo");
		exit(EXIT_FAILURE);
	}

	printf("getaddressinfo client done\n");

	// Connect to first valid result
	// Why are there multiple results? see man page (search 'several reasons')
	// How to search? enter /, then text to search for, press n/N to navigate
	int connecting=0;
	for (rp = servinfo; rp != NULL; rp = rp->ai_next) {
		printf("creating socket now\n");
		upstream_sockfd = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
		printf("socket created successfully\n");

		if (upstream_sockfd == -1)
			continue;

		printf("trying to connect now\n");
		connecting= connect(upstream_sockfd, rp->ai_addr, rp->ai_addrlen) ;
		if (connecting != -1)
			break; // success
		printf("connect to upstream as client done\n");

		close(upstream_sockfd);
	}
	printf("upstream socket %d connecting %d\n",upstream_sockfd,connecting);
	if (rp == NULL) {
		fprintf(stderr, "client: failed to connect\n");
		exit(EXIT_FAILURE);
	}

	// send to upstream here 
	printf("sending to upstream\n");
	num_bytes = send(upstream_sockfd,client_msg,msg_len+2,0);
	if (num_bytes < 0) {
		perror("send");
		exit(EXIT_FAILURE);
	}
	printf("length of data sent to upstream %d\n",num_bytes);

	/* Read length of response from upstream */
	num_bytes = recv(upstream_sockfd,res_len_bytes,TWO_BYTES_HEADER,0);
	if (num_bytes < 0) {
		perror("receive");
		exit(EXIT_FAILURE);
	}

	printf("length of data recv from upstream %02x %02x\n",(res_len_bytes[0]),(res_len_bytes[1]));
	printf("length of data recv from upstream %d\n",(res_len_bytes[0]+res_len_bytes[1]));
	
	/* Length of the response message from the Two bytes header */
	res_msg_len = res_len_bytes[0]+res_len_bytes[1];

	/* Read the rest of the response bases of the length */
	res_msg=(unsigned char*)malloc(sizeof(*res_msg)*res_msg_len);
	num_bytes = recv(upstream_sockfd,res_msg,res_msg_len,0);
	if (num_bytes < 0) {
		perror("receive");
		exit(EXIT_FAILURE);
	}

	print_bytes(res_msg,num_bytes);

	/* Update length of response length for use in local server*/
	(*total_msg_len) = res_msg_len + TWO_BYTES_HEADER;

	/* Combine response's header and the rest of the message*/
	original_res = combine_header_msg(res_len_bytes,res_msg,res_msg_len);

	free(res_msg);
	close(upstream_sockfd);
	freeaddrinfo(servinfo);

	printf("Local Mock Server as client is CLOSED here\n");

	return original_res;
}

unsigned char *combine_header_msg(unsigned char *len_bytes, unsigned char* msg,int msg_len){
	unsigned char *whole_msg;
	whole_msg = (unsigned char*)malloc(sizeof(*whole_msg)*msg_len);
	whole_msg[0] = len_bytes[0];
	whole_msg[1] = len_bytes[1];
	for(int i=0;i<msg_len;i++){
		whole_msg[i+2]=msg[i];
	}
	return whole_msg;
}

void print_bytes(unsigned char *bytes, int len){
	for (int i=0;i<len;i++){
		printf("%02x - ",bytes[i]);
	}
	printf("\n");
}

void handle_req_res(unsigned char *full_msg){
	header_t *header;
    unsigned char *qr;
    question_t *question;
	printf("variable initialisation\n");

	/* Put header to structure */
    header = (header_t *)malloc(sizeof(*header));
	assert(header!=NULL);
	printf("HEADER allocation okay\n");
    put_to_header(header,full_msg);
	printf("put to HEADER okay\n");

    print_header(header);

	printf("HEADER PRINTED\n");
    /* Find message type - QR : message is a question/request or response */
    qr = (unsigned char*)malloc(sizeof(*qr));
	assert(qr!=NULL);

	printf("qr allocation okay\n");
    get_message_type(header->flags,qr);

	printf("MSG TYPE DONE\n");
    /* Put question to structure */
    question = (question_t*)malloc(sizeof(*question));
	assert(question!=NULL);

	printf("question allocation okay\n");

    int next_loc = parse_question(question,full_msg);
	printf("QUESTION DONE\n");

    /* Check whether message is a question/request or response & log */
    log_message(qr,header,next_loc,full_msg,question);
	printf("LOGGING DONE\n");

	// free(header);
	// free(qr);
	// free(question);

}

unsigned char *get_res_msg(unsigned char* original_res,int msg_len){

	unsigned char *res_msg;
	res_msg=(unsigned char*)malloc(sizeof(*res_msg)*msg_len);
	for(int i=0;i<msg_len;i++){
		res_msg[i]=original_res[i+2];
	}
	return res_msg;
}
