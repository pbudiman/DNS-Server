/* 
 * dns_svr.c
 * Create local DNS server 
 * ./dns_svr <upstream ip addr> <port num>
 * Based on W9 practical : server.c & client.c
 * 
 * Patricia Angelica Budiman (1012861)
 * COMP30023 2021 S1 - Project 2
 */

#define CACHE
#define _POSIX_C_SOURCE 200112L
#define TWO_BYTES_HEADER 2
#define LOCAL_SVR_PORT "8053"

#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#include "client.h"
#include "caching.h"
#include "parsing_utils.h"
#include "error_handling.h"

int main(int argc, char** argv) {
	int sockfd_svr, newsockfd_svr, num_bytes, enable_svr, msg_len, upstream_res_len, total_bytes_read;
	unsigned char msg_len_bytes[TWO_BYTES_HEADER], *query_msg, *msg_container, *original_msg, *upstream_res, *upstream_res_msg ;
	struct addrinfo hints_svr, *res_svr;
	struct sockaddr_storage client_addr_svr;
	socklen_t client_addr_size_svr;
	header_t *header;
	question_t *question;
	answer_t *answer;
	cache_entry_t *cache;
	cache_entry_t *cache_record=NULL;

	int cache_success;


	if (argc < 3) {
		fprintf(stderr, "ERROR, both ipv4 address & port required\n");
		exit(EXIT_FAILURE);
	}

	/* Create Cache */
	cache = create_empty_cache();

	/* Create address we're going to listen on (with given port number) */
	memset(&hints_svr, 0, sizeof hints_svr);
	hints_svr.ai_family = AF_INET;       // IPv4
	hints_svr.ai_socktype = SOCK_STREAM; // TCP
	hints_svr.ai_flags = AI_PASSIVE;     // for bind, listen, accept
	/* node (NULL means any interface), service (port), hints_svr, res_svr */
	getaddrinfo(NULL, LOCAL_SVR_PORT, &hints_svr, &res_svr);

	printf("Local Server Port: %s\n",LOCAL_SVR_PORT);
	printf("Upstream IPv4 : %s\n",argv[1]);
	printf("Upstream Port : %s\n",argv[2]);

	/* Create socket */
	sockfd_svr = socket(res_svr->ai_family, res_svr->ai_socktype, res_svr->ai_protocol);
	if (sockfd_svr < 0) {
		perror("socket");
		exit(EXIT_FAILURE);
	}

	/* Reuse port if possible */
	enable_svr = 1;
	if (setsockopt(sockfd_svr, SOL_SOCKET, SO_REUSEADDR, &enable_svr, sizeof(int)) < 0) {
		perror("setsockopt");
		exit(EXIT_FAILURE);
	}

	/* Bind address to the socket */
	if (bind(sockfd_svr, res_svr->ai_addr, res_svr->ai_addrlen) < 0) {
		perror("bind");
		exit(EXIT_FAILURE);
	}

	/* Listen on socket - means we're ready to accept connections,
	 * incoming connection requests will be queued, man 3 listen */
	if (listen(sockfd_svr, 5) < 0) {
		perror("listen");
		exit(EXIT_FAILURE);
	}

	/* Server not shutting down by itself - keeps running until manually terminanted,
	 * separate TCP Connection for each query/res with client(dig) */
	while(1){
		/* Accept a connection - blocks until a connection is ready to be accepted
		* Get back a new file descriptor to communicate on */
		client_addr_size_svr = sizeof client_addr_svr;
		newsockfd_svr = accept(sockfd_svr, (struct sockaddr*)&client_addr_svr, &client_addr_size_svr);
		if (newsockfd_svr < 0) {
			perror("accept");
			exit(EXIT_FAILURE);
		}

		/* Read length of query message from client - dig*/
		/* num_bytes is number of bytes read  */ 
		memset(msg_len_bytes, 'b', TWO_BYTES_HEADER);
		num_bytes = read(newsockfd_svr, msg_len_bytes, TWO_BYTES_HEADER);
		if (num_bytes < 0) {
			perror("write");
			exit(EXIT_FAILURE);
		}

		/* Two byte header : length of message not including the two byte itself*/
		msg_len = msg_len_bytes[0] + msg_len_bytes[1];
		
		/* for the full query message based on msg length */
		query_msg = (unsigned char*)malloc(sizeof(*query_msg)*(msg_len));

		/* for storing the message received - tcp stream */
		msg_container = (unsigned char*)malloc(sizeof(*query_msg)*(msg_len));
		
		
		/* when have not received the full message - tcp stream property
		 * make sure receive the whole message */
		total_bytes_read = 0;
		while (total_bytes_read<msg_len){
			num_bytes = read(newsockfd_svr, msg_container,msg_len);
			
			for(int i=0;i<num_bytes;i++){
				query_msg[i+total_bytes_read] = msg_container[i];
			}
			total_bytes_read+=num_bytes;
		}

		/* Original packet generated by dig */
		original_msg = combine_header_msg(msg_len_bytes,query_msg,msg_len);
		
		/* GET HEADER QUESTION */
		header = (header_t *)malloc(sizeof(*header));
		question = (question_t*)malloc(sizeof(*question));
		int next_loc;
		put_to_header(header,query_msg);
		next_loc = parse_question(question,query_msg);
		log_req(question);

		if(is_non_AAAA(question)){
			/* non-AAAA record request not implemented and not forwarded upstream*/
			rcode_four_error(query_msg);

			/* Original packet generated by dig */
			original_msg = combine_header_msg(msg_len_bytes,query_msg,msg_len);

			/* Send answer back to client - dig */
			num_bytes = send(newsockfd_svr,original_msg,msg_len+2,0);
			if (num_bytes < 0) {
				perror("send");
				exit(EXIT_FAILURE);
			}
		}else{
			cache_record = (cache_entry_t *)malloc(sizeof(*cache_record));
			if(in_cache(cache,question->q_name)!=-1){
				/* Response from cache */
				update_cache_ttl(cache);
				cache_success = get_from_cache(cache,question->q_name,cache_record);
				
				if(!cache_success){
					
					upstream_res = client_for_upstream(original_msg,msg_len,argv[2], argv[1],&upstream_res_len);
				}else{
					get_from_cache(cache,question->q_name,cache_record);
					upstream_res = cache_record->full_response;
				}

				edit_trans_id(upstream_res,header->tran_id);
				print_bytes(upstream_res,msg_len);
	
			}else{
			/* Response from upstream */
				upstream_res = client_for_upstream(original_msg,msg_len,argv[2], argv[1],&upstream_res_len);
			}
	
			/* Get response message from upstream without Two bytes header */
			upstream_res_msg = get_res_msg(upstream_res,(upstream_res_len-2));
			
			answer= (answer_t*)malloc(sizeof(*answer));

			put_to_header(header,upstream_res_msg);
			next_loc = parse_question(question,query_msg);
			parse_answer(answer,next_loc,upstream_res_msg);

			/* Renewing existing record in cache */
			bool renew_existing= ((in_cache(cache,question->q_name)!=-1) && (cache_success==0));
			
			
			cache_entry_t *expired_rec = get_expired_rec(cache);
			bool replace_expired = ((in_cache(cache,question->q_name)==-1) && (expired_rec!=NULL));
			if(strcmp(question->q_name,"1.comp30023")==0){
				get_expired_rec(cache);
			}

			if(replace_expired){
				log_replacement(expired_rec->domain_name,question->q_name);
				renew_cache_record(cache,question->q_name,answer->ttl,upstream_res,upstream_res_len,0);
			} 

			
			if(renew_existing){
				log_replacement(question->q_name,question->q_name);
				renew_cache_record(cache,question->q_name,answer->ttl,upstream_res,upstream_res_len,1);

			}

			if(cache_success && !replace_expired && !renew_existing){
				log_res(question,answer,header,cache_record);
				free(cache_record);
			}else{
				log_res(question,answer,header,NULL);

			}
			
			print_bytes(upstream_res_msg,upstream_res_len);

			/* Adding new record to cache */
			if(check_empty_cache(cache) && (in_cache(cache,question->q_name)==-1)){
				add_to_cache(cache,question->q_name,answer->ttl,upstream_res,upstream_res_len);
			}

			/* Send answer back to client - dig */
			num_bytes = send(newsockfd_svr,upstream_res,upstream_res_len,0);
			if (num_bytes < 0) {
				perror("send");
				exit(EXIT_FAILURE);
			}
			free(question);
			free(answer);
			free(header);
			free(query_msg);
			free(original_msg);
			free(upstream_res);
			free(upstream_res_msg);
		}
	}

	freeaddrinfo(res_svr);
	close(sockfd_svr);
	close(newsockfd_svr);
	return 0;
}


